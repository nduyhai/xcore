package main

import (
	"bytes"
	"flag"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"gopkg.in/yaml.v3"
)

// Config represents the structure of the YAML configuration file.
type Config struct {
	Package        string     `yaml:"package"`
	Import         string     `yaml:"import"`
	OutputFilePath string     `yaml:"output_filepath"`
	Domain         string     `yaml:"domain"`
	Errors         []ErrorDef `yaml:"errors"`
}

// ErrorDef defines the structure of each error in the YAML file.
type ErrorDef struct {
	Name           string `yaml:"name"`
	Message        string `yaml:"message"`
	HttpStatusCode int    `yaml:"http_status_code,omitempty"`
	GrpcCode       string `yaml:"grpc_code,omitempty"`
	Comment        string `yaml:"comment,omitempty"` // Optional comment
	GeneratedCode  string // Auto-generated code based on domain + incremental number
	GeneratedName  string // Auto-generated variable name with domain prefix
}

// getConstructor determines which constructor to use based on available fields
func getConstructor(importPath string, errDef ErrorDef) string {
	if importPath == "" {
		return "NewSimpleReason"
	}

	// Extract package name from import path
	parts := strings.Split(importPath, "/")
	pkg := parts[len(parts)-1]

	hasHTTP := errDef.HttpStatusCode > 0
	hasGRPC := errDef.GrpcCode != ""

	if hasHTTP && hasGRPC {
		return pkg + ".NewMultiReason"
	} else if hasHTTP {
		return pkg + ".NewHTTPReason"
	} else if hasGRPC {
		return pkg + ".NewGRPCReason"
	} else {
		return pkg + ".NewSimpleReason"
	}
}

// getParameters builds the parameter string for constructor calls
func getParameters(errDef ErrorDef) string {
	params := []string{
		fmt.Sprintf(`"%s"`, errDef.GeneratedCode),
		fmt.Sprintf(`"%s"`, errDef.Message),
	}

	hasHTTP := errDef.HttpStatusCode > 0
	hasGRPC := errDef.GrpcCode != ""

	if hasHTTP && hasGRPC {
		// MultiReason: code, message, httpStatus, grpcCode
		params = append(params, fmt.Sprintf("%d", errDef.HttpStatusCode))
		params = append(params, fmt.Sprintf("codes.%s", errDef.GrpcCode))
	} else if hasHTTP {
		// HTTPReason: code, message, httpStatus
		params = append(params, fmt.Sprintf("%d", errDef.HttpStatusCode))
	} else if hasGRPC {
		// GRPCReason: code, message, grpcCode
		params = append(params, fmt.Sprintf("codes.%s", errDef.GrpcCode))
	}
	// SimpleReason: just code, message (no additional params)

	return strings.Join(params, ", ")
}

// goTemplate is the template for the generated Go file.
const goTemplate = `// Code generated by xgen. DO NOT EDIT.

package {{.Package}}

{{- if .Import }}

import (
	"{{.Import}}"
	{{- if hasGRPC .Errors }}
	"google.golang.org/grpc/codes"
	{{- end }}
)
{{- end }}

var (
{{- range .Errors }}
	// {{.GeneratedName}} represents {{.Message}}{{if .Comment}} - {{.Comment}}{{end}}
	{{.GeneratedName}} = {{getConstructor $.Import .}}({{getParameters .}})
{{- end }}
)
`

// hasGRPC checks if any error definition uses gRPC codes
func hasGRPC(errors []ErrorDef) bool {
	for _, err := range errors {
		if err.GrpcCode != "" {
			return true
		}
	}
	return false
}

func main() {
	// Define command-line flags.
	configPath := flag.String("config", "errors.yaml", "Path to the YAML configuration file")
	flag.Parse()

	// Read the YAML configuration file.
	data, err := os.ReadFile(*configPath)
	if err != nil {
		fmt.Printf("Failed to read YAML file '%s': %v\n", *configPath, err)
		os.Exit(1)
	}

	// Unmarshal the YAML data into Config struct.
	var config Config
	err = yaml.Unmarshal(data, &config)
	if err != nil {
		fmt.Printf("Failed to parse YAML file '%s': %v\n", *configPath, err)
		os.Exit(1)
	}

	// Validate the configuration.
	if err := validateConfig(config); err != nil {
		fmt.Printf("Configuration validation failed: %v\n", err)
		os.Exit(1)
	}

	if len(config.Errors) == 0 {
		fmt.Println("No errors defined in the configuration. Exiting.")
		os.Exit(0)
	}

	// Generate auto-generated codes based on domain and ordering
	generateErrorCodes(&config)

	// Ensure OutputFilePath is specified.
	if config.OutputFilePath == "" {
		fmt.Println("'output_filepath' is not specified in the YAML configuration.")
		os.Exit(1)
	}

	// Generate the Go file.
	if err := generateGoFile(config); err != nil {
		fmt.Printf("Failed to generate Go file: %v\n", err)
		os.Exit(1)
	}
}

// validateConfig checks for unique error names and ensures required fields are present.
func validateConfig(config Config) error {
	// Check if domain is specified
	if config.Domain == "" {
		return fmt.Errorf("'domain' is required for auto-generated error codes")
	}

	nameSet := make(map[string]struct{})

	for idx, errDef := range config.Errors {
		// Check for missing required fields.
		if errDef.Name == "" {
			return fmt.Errorf("error at index %d is missing 'name'", idx)
		}
		if errDef.Message == "" {
			return fmt.Errorf("error at index %d is missing 'message'", idx)
		}

		// Check for duplicate names.
		if _, exists := nameSet[errDef.Name]; exists {
			return fmt.Errorf("duplicate error name detected: '%s'", errDef.Name)
		}
		nameSet[errDef.Name] = struct{}{}
	}

	return nil
}

// generateErrorCodes assigns auto-generated codes and names to all errors based on domain and ordering
func generateErrorCodes(config *Config) {
	for i := range config.Errors {
		// Generate code as domain + incremental number (starting from 1)
		config.Errors[i].GeneratedCode = fmt.Sprintf("%s_%d", config.Domain, i+1)
		// Generate variable name with domain prefix (e.g., PaymentUserIDNotFound)
		config.Errors[i].GeneratedName = strings.Title(strings.ToLower(config.Domain)) + config.Errors[i].Name
	}
}

// generateGoFile creates the Go file with error definitions based on the provided configuration.
func generateGoFile(config Config) error {
	// Parse the Go template with custom functions.
	funcMap := template.FuncMap{
		"getConstructor": getConstructor,
		"getParameters":  getParameters,
		"hasGRPC":        hasGRPC,
	}

	tmpl, err := template.New("go").Funcs(funcMap).Parse(goTemplate)
	if err != nil {
		return fmt.Errorf("failed to parse Go template: %v", err)
	}

	// Execute the template with the configuration data.
	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, config); err != nil {
		return fmt.Errorf("failed to execute Go template: %v", err)
	}

	// Ensure the output directory exists.
	dir := filepath.Dir(config.OutputFilePath)
	if dir != "." {
		if _, err := os.Stat(dir); os.IsNotExist(err) {
			fmt.Printf("Creating directory '%s'\n", dir)
			if err := os.MkdirAll(dir, 0755); err != nil {
				return fmt.Errorf("failed to create directory '%s': %v", dir, err)
			}
		}
	}

	// Get the absolute path of the output file.
	absPath, err := filepath.Abs(config.OutputFilePath)
	if err != nil {
		return fmt.Errorf("failed to get absolute path of '%s': %v", config.OutputFilePath, err)
	}

	// Write the generated Go code to the output file.
	if err := os.WriteFile(absPath, buf.Bytes(), 0644); err != nil {
		return fmt.Errorf("failed to write Go file '%s': %v", absPath, err)
	}

	fmt.Printf("Successfully generated Go file '%s'\n", absPath)
	return nil
}
