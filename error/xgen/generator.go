package main

import (
	"bytes"
	"flag"
	"fmt"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"text/template"

	"gopkg.in/yaml.v3"
)

// Config represents the structure of the YAML configuration file.
type Config struct {
	Package        string     `yaml:"package"`
	Import         string     `yaml:"import"`
	OutputFilePath string     `yaml:"output_filepath"`
	Domain         string     `yaml:"domain"`
	Errors         []ErrorDef `yaml:"errors"`
}

// ErrorDef defines the structure of each error in the YAML file.
type ErrorDef struct {
	Name           string `yaml:"name"`
	Message        string `yaml:"message"`
	HTTPStatusCode int    `yaml:"http_status_code,omitempty"`
	GrpcCode       string `yaml:"grpc_code,omitempty"`
	Comment        string `yaml:"comment,omitempty"` // Optional comment
	GeneratedCode  string // Auto-generated code based on domain + incremental number
	GeneratedName  string // Auto-generated variable name with domain prefix
}

const (
	dirPerm  = 0o755
	filePerm = 0o644

	// Package import paths
	xerrPackage      = "github.com/nduyhai/xcore/error/xerr"
	gerrPackage      = "github.com/nduyhai/xcore/error/gerr"
	grpcCodesPackage = "google.golang.org/grpc/codes"
)

// hasHTTP reports if HTTP status code is present.
func hasHTTP(errDef ErrorDef) bool {
	return errDef.HTTPStatusCode > 0
}

// hasGRPC reports if gRPC code is present.
func hasGRPC(errDef ErrorDef) bool {
	return errDef.GrpcCode != ""
}

// anyUsesGRPC checks if any error definition uses gRPC codes.
func anyUsesGRPC(errors []ErrorDef) bool {
	for _, err := range errors {
		if hasGRPC(err) {
			return true
		}
	}
	return false
}

// requiresGerr checks if any error definition needs gerr package constructors.
func requiresGerr(errors []ErrorDef) bool {
	for _, err := range errors {
		hHTTP := hasHTTP(err)
		hGRPC := hasGRPC(err)
		// Need gerr package for MultiReason (both HTTP and gRPC) or GRPCReason (gRPC only)
		if (hHTTP && hGRPC) || (hGRPC && !hHTTP) {
			return true
		}
	}
	return false
}

// requiresXerr checks if any error definition needs xerr package constructors.
func requiresXerr(errors []ErrorDef) bool {
	for _, err := range errors {
		hHTTP := hasHTTP(err)
		hGRPC := hasGRPC(err)
		// Need xerr package for HTTPReason (HTTP only) or MultiReason (both HTTP and gRPC)
		if (hHTTP && !hGRPC) || (hHTTP && hGRPC) {
			return true
		}
	}
	return false
}

// selectConstructor determines which constructor to use based on available fields.
func selectConstructor(errDef ErrorDef) string {
	hHTTP := hasHTTP(errDef)
	hGRPC := hasGRPC(errDef)
	if hHTTP && hGRPC {
		return "gerr.NewMultiReason"
	} else if hHTTP {
		return "xerr.NewHTTPReason"
	} else if hGRPC {
		return "gerr.NewGRPCReason"
	}
	return "xerr.NewSimpleReason"
}

// buildConstructorParams builds the parameter string for constructor calls.
func buildConstructorParams(errDef ErrorDef) string {
	params := []string{
		fmt.Sprintf(`"%s"`, errDef.GeneratedCode),
		fmt.Sprintf(`"%s"`, errDef.Message),
	}
	hHTTP := hasHTTP(errDef)
	hGRPC := hasGRPC(errDef)

	if hHTTP && hGRPC {
		// MultiReason: code, message, httpStatus, grpcCode
		params = append(params, strconv.Itoa(errDef.HTTPStatusCode))
		params = append(params, fmt.Sprintf("codes.%s", errDef.GrpcCode))
	} else if hHTTP {
		// HTTPReason: code, message, httpStatus
		params = append(params, strconv.Itoa(errDef.HTTPStatusCode))
	} else if hGRPC {
		// GRPCReason: code, message, grpcCode
		params = append(params, fmt.Sprintf("codes.%s", errDef.GrpcCode))
	}
	// SimpleReason: just code, message (no additional params)
	return strings.Join(params, ", ")
}

// goTemplate is the template for the generated Go file.
var goTemplate = `// Code generated by xgen. DO NOT EDIT.
package {{.Package}}

import (
	{{- if requiresXerr .Errors }}
	"` + xerrPackage + `"
	{{- end }}
	{{- if requiresGerr .Errors }}
	"` + gerrPackage + `"
	{{- end }}
	{{- if anyUsesGRPC .Errors }}
	"` + grpcCodesPackage + `"
	{{- end }}
)

var (
{{- range .Errors }}
	// {{.GeneratedName}} represents {{.Message}}{{if .Comment}} - {{.Comment}}{{end}}
	{{.GeneratedName}} = {{selectConstructor .}}({{buildConstructorParams .}})
{{- end }}
)
`

func main() {
	// Define command-line flags.
	configPath := flag.String("config", "errors.yaml", "Path to the YAML configuration file")
	flag.Parse()

	// Read the YAML configuration file.
	data, err := os.ReadFile(*configPath)
	if err != nil {
		fmt.Printf("Failed to read YAML file '%s': %v\n", *configPath, err)
		os.Exit(1)
	}

	// Unmarshal the YAML data into Config struct.
	var config Config
	if err := yaml.Unmarshal(data, &config); err != nil {
		fmt.Printf("Failed to parse YAML file '%s': %v\n", *configPath, err)
		os.Exit(1)
	}

	// Validate the configuration.
	if err := validateConfig(config); err != nil {
		fmt.Printf("Configuration validation failed: %v\n", err)
		os.Exit(1)
	}
	if len(config.Errors) == 0 {
		fmt.Println("No errors defined in the configuration. Exiting.")
		os.Exit(0)
	}

	// Generate auto-generated codes based on domain and ordering.
	generateErrorCodes(&config)

	// Ensure OutputFilePath is specified.
	if config.OutputFilePath == "" {
		fmt.Println("'output_filepath' is not specified in the YAML configuration.")
		os.Exit(1)
	}

	// Generate the Go file.
	if err := generateGoFile(config); err != nil {
		fmt.Printf("Failed to generate Go file: %v\n", err)
		os.Exit(1)
	}
}

// validateConfig checks for unique error names and ensures required fields are present.
func validateConfig(config Config) error {
	// Check if domain is specified.
	if config.Domain == "" {
		return fmt.Errorf("'domain' is required for auto-generated error codes")
	}
	nameSet := make(map[string]struct{})
	for idx, errDef := range config.Errors {
		// Check for missing required fields.
		if errDef.Name == "" {
			return fmt.Errorf("error at index %d is missing 'name'", idx)
		}
		if errDef.Message == "" {
			return fmt.Errorf("error at index %d is missing 'message'", idx)
		}
		// Check for duplicate names.
		if _, exists := nameSet[errDef.Name]; exists {
			return fmt.Errorf("duplicate error name detected: '%s'", errDef.Name)
		}
		nameSet[errDef.Name] = struct{}{}
	}
	return nil
}

// titleCase converts a string's first rune to upper-case, leaving the rest as-is (ASCII-safe).
func titleCase(s string) string {
	if s == "" {
		return s
	}
	b := []rune(s)
	if b[0] >= 'a' && b[0] <= 'z' {
		b[0] = b[0] - ('a' - 'A')
	}
	return string(b)
}

// generateErrorCodes assigns auto-generated codes and names to all errors based on domain and ordering.
func generateErrorCodes(config *Config) {
	for i := range config.Errors {
		// Generate code as domain + incremental number (starting from 1).
		config.Errors[i].GeneratedCode = fmt.Sprintf("%s_%d", config.Domain, i+1)
		// Generate variable name with domain prefix (e.g., PaymentUserIDNotFound).
		config.Errors[i].GeneratedName = titleCase(strings.ToLower(config.Domain)) + config.Errors[i].Name
	}
}

// generateGoFile creates the Go file with error definitions based on the provided configuration.
func generateGoFile(config Config) error {
	// Parse the Go template with custom functions.
	funcMap := template.FuncMap{
		"selectConstructor":      selectConstructor,
		"buildConstructorParams": buildConstructorParams,
		"anyUsesGRPC":            anyUsesGRPC,
		"requiresGerr":           requiresGerr,
		"requiresXerr":           requiresXerr,
	}
	tmpl, err := template.New("go").Funcs(funcMap).Parse(goTemplate)
	if err != nil {
		return fmt.Errorf("failed to parse Go template: %v", err)
	}

	// Execute the template with the configuration data.
	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, config); err != nil {
		return fmt.Errorf("failed to execute Go template: %v", err)
	}

	// Ensure the output directory exists.
	dir := filepath.Dir(config.OutputFilePath)
	if dir != "." {
		_, statErr := os.Stat(dir)
		dirMissing := os.IsNotExist(statErr)
		if dirMissing {
			fmt.Printf("Creating directory '%s'\n", dir)
			if err := os.MkdirAll(dir, dirPerm); err != nil {
				return fmt.Errorf("failed to create directory '%s': %v", dir, err)
			}
		}
	}

	// Get the absolute path of the output file.
	absPath, err := filepath.Abs(config.OutputFilePath)
	if err != nil {
		return fmt.Errorf("failed to get absolute path of '%s': %v", config.OutputFilePath, err)
	}

	// Write the generated Go code to the output file.
	if err := os.WriteFile(absPath, buf.Bytes(), filePerm); err != nil {
		return fmt.Errorf("failed to write Go file '%s': %v", absPath, err)
	}
	fmt.Printf("Successfully generated Go file '%s'\n", absPath)
	return nil
}
